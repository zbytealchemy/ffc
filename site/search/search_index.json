{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Firefly Catcher Framework","text":"<p>Welcome to the Firefly Catcher Framework documentation! This framework provides a powerful foundation for building AI-powered automation tools.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Firefly Catcher Framework (FFC) is designed to make it easy to create, deploy, and manage AI agents that can interact with various tools and systems. Whether you're building a simple automation script or a complex AI-powered application, FFC provides the building blocks you need.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible Runtime: Support for both Python and JavaScript</li> <li>Extensible Tools: Easy-to-use interface for creating custom tools</li> <li>IDE Integration: First-class support for VS Code and IntelliJ</li> <li>CLI Tools: Powerful command-line interface for automation</li> <li>Type Safety: Built with type safety in mind using TypeScript and Python type hints</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out our Getting Started Guide to begin building with FFC.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"api/runtime/","title":"Runtime API Reference","text":"<p>This document provides detailed API documentation for the FFC Runtime components.</p>"},{"location":"api/runtime/#core-components","title":"Core Components","text":""},{"location":"api/runtime/#agentruntimeengine","title":"AgentRuntimeEngine","text":"<p>The main engine responsible for executing agent specifications.</p> <pre><code>class AgentRuntimeEngine:\n    def __init__(self, spec: AgentSpec, working_dir: Path):\n        \"\"\"Initialize the runtime engine.\n\n        Args:\n            spec: Agent specification dictionary\n            working_dir: Working directory for the agent\n        \"\"\"\n\n    def start(self) -&gt; None:\n        \"\"\"Start the runtime engine.\"\"\"\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the runtime engine.\"\"\"\n\n    def register_tool(self, name: str, tool: Any) -&gt; None:\n        \"\"\"Register a tool with the engine.\"\"\"\n</code></pre>"},{"location":"api/runtime/#agentspec","title":"AgentSpec","text":"<p>Type definition for agent specifications.</p> <pre><code>AgentSpec = Dict[str, Any]\n\"\"\"\n{\n    \"name\": str,\n    \"description\": str,\n    \"tools\": List[ToolSpec],\n    \"permissions\": List[Permission],\n    \"resource_limits\": Optional[ResourceLimits]\n}\n\"\"\"\n</code></pre>"},{"location":"api/runtime/#permission","title":"Permission","text":"<p>Defines access permissions for resources.</p> <pre><code>@dataclass\nclass Permission:\n    resource: str  # Resource pattern (e.g., \"data/*\")\n    actions: List[str]  # Allowed actions (e.g., [\"read\", \"write\"])\n</code></pre>"},{"location":"api/runtime/#resourcelimits","title":"ResourceLimits","text":"<p>Defines resource constraints for agents.</p> <pre><code>@dataclass\nclass ResourceLimits:\n    cpu: str  # CPU limit (e.g., \"1\")\n    memory: str  # Memory limit (e.g., \"1Gi\")\n    storage: Optional[str]  # Storage limit\n</code></pre>"},{"location":"api/runtime/#agent-components","title":"Agent Components","text":""},{"location":"api/runtime/#agentrunner","title":"AgentRunner","text":"<p>Interface for executing agent specifications.</p> <pre><code>class AgentRunner:\n    @classmethod\n    async def from_file(cls, spec_path: Path) -&gt; \"AgentRunner\":\n        \"\"\"Create runner from specification file.\"\"\"\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the agent runner.\"\"\"\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the agent runner.\"\"\"\n\n    async def execute_command(self, command: str) -&gt; ToolResult:\n        \"\"\"Execute a command using the runtime engine.\"\"\"\n</code></pre>"},{"location":"api/runtime/#agentorchestrator","title":"AgentOrchestrator","text":"<p>Manages distributed agent lifecycles.</p> <pre><code>class AgentOrchestrator:\n    async def deploy_agent(\n        self,\n        spec: AgentSpec,\n        parent_id: Optional[str] = None\n    ) -&gt; str:\n        \"\"\"Deploy a new agent.\"\"\"\n\n    async def terminate_agent(self, agent_id: str) -&gt; None:\n        \"\"\"Terminate an agent.\"\"\"\n\n    async def get_agent_status(self, agent_id: str) -&gt; AgentStatus:\n        \"\"\"Get agent status.\"\"\"\n</code></pre>"},{"location":"api/runtime/#tool-system","title":"Tool System","text":""},{"location":"api/runtime/#toolspec","title":"ToolSpec","text":"<p>Type definition for tool specifications.</p> <pre><code>ToolSpec = Dict[str, Any]\n\"\"\"\n{\n    \"name\": str,\n    \"description\": str,\n    \"class\": str,\n    \"config\": Optional[Dict[str, Any]]\n}\n\"\"\"\n</code></pre>"},{"location":"api/runtime/#toolresult","title":"ToolResult","text":"<p>Type definition for tool execution results.</p> <pre><code>ToolResult = Dict[str, Any]\n\"\"\"\n{\n    \"success\": bool,\n    \"result\": Any,\n    \"error\": Optional[str]\n}\n\"\"\"\n</code></pre>"},{"location":"api/runtime/#error-handling","title":"Error Handling","text":""},{"location":"api/runtime/#exceptions","title":"Exceptions","text":"<pre><code>class AgentError(Exception):\n    \"\"\"Base class for agent-related errors.\"\"\"\n\nclass ToolExecutionError(AgentError):\n    \"\"\"Error during tool execution.\"\"\"\n\nclass PermissionError(AgentError):\n    \"\"\"Permission-related error.\"\"\"\n\nclass ResourceExceededError(AgentError):\n    \"\"\"Resource limit exceeded.\"\"\"\n</code></pre>"},{"location":"api/runtime/#usage-examples","title":"Usage Examples","text":""},{"location":"api/runtime/#creating-and-running-an-agent","title":"Creating and Running an Agent","text":"<pre><code># Create agent specification\nspec = {\n    \"name\": \"data-processor\",\n    \"description\": \"Processes data files\",\n    \"tools\": [\n        {\n            \"name\": \"process_data\",\n            \"class\": \"DataProcessingTool\",\n            \"config\": {\"format\": \"csv\"}\n        }\n    ],\n    \"permissions\": [\n        Permission(resource=\"data/*\", actions=[\"read\"])\n    ],\n    \"resource_limits\": ResourceLimits(cpu=\"1\", memory=\"1Gi\")\n}\n\n# Create and start agent\nrunner = AgentRunner(spec)\nawait runner.start()\n\n# Execute commands\nresult = await runner.execute_command(\"process_data\")\n\n# Stop agent\nawait runner.stop()\n</code></pre>"},{"location":"api/runtime/#managing-distributed-agents","title":"Managing Distributed Agents","text":"<pre><code># Initialize orchestrator\norchestrator = AgentOrchestrator(namespace=\"ffc-agents\")\n\n# Deploy agent\nagent_id = await orchestrator.deploy_agent(spec)\n\n# Monitor status\nstatus = await orchestrator.get_agent_status(agent_id)\n\n# Terminate when done\nawait orchestrator.terminate_agent(agent_id)\n</code></pre>"},{"location":"api/tools/","title":"Tools API Reference","text":"<p>This document provides detailed API documentation for the FFC Tools system.</p>"},{"location":"api/tools/#core-tool-system","title":"Core Tool System","text":""},{"location":"api/tools/#basetool","title":"BaseTool","text":"<p>Base class for all tools.</p> <pre><code>class BaseTool:\n    async def execute(self, args: Dict[str, Any], state: Any) -&gt; ToolResult:\n        \"\"\"Execute the tool.\n\n        Args:\n            args: Tool arguments\n            state: Current agent state\n\n        Returns:\n            Tool execution result\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/tools/#createagenttool","title":"CreateAgentTool","text":"<p>Tool for creating child agents.</p> <pre><code>class CreateAgentTool:\n    def __init__(self, orchestrator: AgentOrchestrator, parent_id: Optional[str]):\n        \"\"\"Initialize the tool.\n\n        Args:\n            orchestrator: Agent orchestrator instance\n            parent_id: Parent agent ID\n        \"\"\"\n\n    async def execute(\n        self,\n        args: Dict[str, str],\n        state: Any\n    ) -&gt; ToolResult:\n        \"\"\"Execute the tool.\n\n        Args:\n            args: Must contain 'spec' with agent specification\n            state: Current agent state\n\n        Returns:\n            Tool execution result with child agent ID\n        \"\"\"\n</code></pre>"},{"location":"api/tools/#built-in-tools","title":"Built-in Tools","text":""},{"location":"api/tools/#filesystemtool","title":"FileSystemTool","text":"<p>Tool for file system operations.</p> <pre><code>class FileSystemTool(BaseTool):\n    \"\"\"Tool for file system operations.\"\"\"\n\n    async def execute(\n        self,\n        args: Dict[str, Any],\n        state: Any\n    ) -&gt; ToolResult:\n        \"\"\"Execute file system operations.\n\n        Args:\n            args: {\n                \"operation\": str,  # read, write, delete\n                \"path\": str,\n                \"content\": Optional[str]\n            }\n        \"\"\"\n</code></pre>"},{"location":"api/tools/#httptool","title":"HTTPTool","text":"<p>Tool for making HTTP requests.</p> <pre><code>class HTTPTool(BaseTool):\n    \"\"\"Tool for making HTTP requests.\"\"\"\n\n    async def execute(\n        self,\n        args: Dict[str, Any],\n        state: Any\n    ) -&gt; ToolResult:\n        \"\"\"Execute HTTP request.\n\n        Args:\n            args: {\n                \"method\": str,\n                \"url\": str,\n                \"headers\": Optional[Dict],\n                \"body\": Optional[Any]\n            }\n        \"\"\"\n</code></pre>"},{"location":"api/tools/#tool-configuration","title":"Tool Configuration","text":""},{"location":"api/tools/#toolconfig","title":"ToolConfig","text":"<p>Configuration for tool initialization.</p> <pre><code>@dataclass\nclass ToolConfig:\n    name: str\n    description: str\n    permissions: List[Permission]\n    config: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/tools/#tool-registration","title":"Tool Registration","text":"<pre><code># Register tool with runtime engine\nengine.register_tool(\n    name=\"create_agent\",\n    tool=CreateAgentTool(orchestrator, agent_id)\n)\n</code></pre>"},{"location":"api/tools/#tool-development","title":"Tool Development","text":""},{"location":"api/tools/#creating-custom-tools","title":"Creating Custom Tools","text":"<pre><code>class CustomTool(BaseTool):\n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n\n    async def execute(\n        self,\n        args: Dict[str, Any],\n        state: Any\n    ) -&gt; ToolResult:\n        # Tool implementation\n        result = await self._process(args)\n        return {\n            \"success\": True,\n            \"result\": result\n        }\n</code></pre>"},{"location":"api/tools/#tool-permissions","title":"Tool Permissions","text":"<pre><code># Define tool permissions\ntool_permissions = [\n    Permission(\n        resource=\"data/*\",\n        actions=[\"read\", \"write\"]\n    )\n]\n\n# Create tool with permissions\ntool_config = ToolConfig(\n    name=\"data_processor\",\n    description=\"Processes data files\",\n    permissions=tool_permissions\n)\n</code></pre>"},{"location":"api/tools/#error-handling","title":"Error Handling","text":""},{"location":"api/tools/#tool-specific-exceptions","title":"Tool-specific Exceptions","text":"<pre><code>class ToolError(Exception):\n    \"\"\"Base class for tool-related errors.\"\"\"\n\nclass ToolConfigError(ToolError):\n    \"\"\"Tool configuration error.\"\"\"\n\nclass ToolExecutionError(ToolError):\n    \"\"\"Tool execution error.\"\"\"\n</code></pre>"},{"location":"api/tools/#usage-examples","title":"Usage Examples","text":""},{"location":"api/tools/#basic-tool-usage","title":"Basic Tool Usage","text":"<pre><code># Create and configure tool\ntool = HTTPTool()\n\n# Execute tool\nresult = await tool.execute({\n    \"method\": \"GET\",\n    \"url\": \"https://api.example.com/data\",\n    \"headers\": {\"Authorization\": \"Bearer token\"}\n}, state={})\n\n# Handle result\nif result[\"success\"]:\n    data = result[\"result\"]\nelse:\n    error = result[\"error\"]\n</code></pre>"},{"location":"api/tools/#complex-tool-integration","title":"Complex Tool Integration","text":"<pre><code># Create tool chain\ntools = [\n    FileSystemTool(),\n    DataProcessingTool(),\n    HTTPTool()\n]\n\n# Register tools with engine\nfor tool in tools:\n    engine.register_tool(tool.name, tool)\n\n# Execute tool chain\nfor tool in tools:\n    result = await tool.execute(args, state)\n    state = update_state(state, result)\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>The Firefly Catcher Framework (FFC) is built on a modular, scalable architecture designed for AI agent orchestration and execution. Here's a comprehensive overview of the system's key components.</p>"},{"location":"architecture/overview/#system-architecture","title":"System Architecture","text":"<p>The FFC Framework consists of two main layers: the Orchestrator Layer and the Agent Layer, working together to provide a robust agent execution environment.</p> <pre><code>graph TB\n    subgraph \"Orchestrator Layer\"\n        O[AgentOrchestrator] --&gt; |deploy| K8s[(Kubernetes)]\n        O --&gt; |manage| AM[Agent Metadata]\n        O --&gt; |execute| CMD[Commands]\n        O --&gt; |monitor| Status[Agent Status]\n    end\n\n    subgraph \"Agent Layer\"\n        AR[AgentRunner] --&gt; |runs| E[Engine]\n        E --&gt; |executes| T[Tools]\n        E --&gt; |processes| Tasks[Tasks]\n        AR --&gt; |reports| Status\n    end\n\n    subgraph \"Infrastructure\"\n        K8s --&gt; |creates| P[Pod]\n        P --&gt; |runs| AR\n    end\n\n    Client[Client] --&gt; |1. deploy| O\n    Client --&gt; |2. interact| O\n    O --&gt; |3. manage lifecycle| AR</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-orchestrator-layer-agentorchestrator","title":"1. Orchestrator Layer (<code>AgentOrchestrator</code>)","text":"<p>The Orchestrator manages the complete lifecycle of agents and their resources:</p>"},{"location":"architecture/overview/#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Agent Deployment: Creates and manages Kubernetes deployments and services</li> <li>Resource Management: Handles compute resources and scaling</li> <li>Command Execution: Routes commands to appropriate agents</li> <li>Status Monitoring: Tracks agent health and status</li> <li>Hierarchy Management: Maintains parent-child relationships</li> </ul>"},{"location":"architecture/overview/#key-operations","title":"Key Operations","text":"<pre><code>deploy_agent()      # Creates K8s deployment &amp; service\nterminate_agent()   # Cleans up resources\nexecute_command()   # Sends commands to agents\nget_agent_status()  # Monitors agent health\nget_agent_tree()    # Tracks agent hierarchy\n</code></pre>"},{"location":"architecture/overview/#2-agent-layer-agentrunner","title":"2. Agent Layer (<code>AgentRunner</code>)","text":"<p>The Agent Runner executes the agent's logic and manages its lifecycle:</p>"},{"location":"architecture/overview/#components","title":"Components","text":"<ul> <li>Engine: Core execution engine for processing tasks</li> <li>Tools: Task-specific implementations (e.g., FileReader, FileWriter)</li> <li>State: Agent's current state and configuration</li> <li>Tasks: Queue of tasks to be processed</li> </ul>"},{"location":"architecture/overview/#key-operations_1","title":"Key Operations","text":"<pre><code>start()            # Initializes and starts the agent\nstop()             # Gracefully terminates\nexecute_command()  # Runs agent commands\nprocess_tasks()    # Handles agent tasks\n</code></pre>"},{"location":"architecture/overview/#3-llm-integration","title":"3. LLM Integration","text":"<p>The LLM system provides: - Flexible provider interface for multiple LLM services - Template management for prompts - Context handling and token management - Error handling and fallback strategies</p>"},{"location":"architecture/overview/#4-tool-system","title":"4. Tool System","text":"<p>The tool system enables: - Custom tool creation and registration - Permission-based tool access - Standardized tool execution interface - Resource usage tracking</p>"},{"location":"architecture/overview/#operational-flows","title":"Operational Flows","text":""},{"location":"architecture/overview/#1-deployment-flow","title":"1. Deployment Flow","text":"<pre><code>Client -&gt; Orchestrator -&gt; Kubernetes -&gt; Pod -&gt; AgentRunner\n</code></pre>"},{"location":"architecture/overview/#2-command-execution-flow","title":"2. Command Execution Flow","text":"<pre><code>Client -&gt; Orchestrator -&gt; Service Discovery -&gt; Agent Endpoint -&gt; AgentRunner -&gt; Tool\n</code></pre>"},{"location":"architecture/overview/#3-status-monitoring-flow","title":"3. Status Monitoring Flow","text":"<pre><code>Orchestrator -&gt; Kubernetes API -&gt; Pod Status\n              -&gt; Agent API -&gt; Agent Health\n</code></pre>"},{"location":"architecture/overview/#4-parent-child-relationship-flow","title":"4. Parent-Child Relationship Flow","text":"<pre><code>Parent Agent -&gt; Orchestrator -&gt; Deploy Child -&gt; Manage Hierarchy\n</code></pre>"},{"location":"architecture/overview/#key-features","title":"Key Features","text":"<ol> <li>Scalability:</li> <li>Kubernetes-based orchestration</li> <li>Dynamic resource allocation</li> <li> <p>Horizontal scaling capabilities</p> </li> <li> <p>Isolation:</p> </li> <li>Each agent runs in its own pod</li> <li>Resource limits per agent</li> <li> <p>Secure inter-agent communication</p> </li> <li> <p>Hierarchy:</p> </li> <li>Parent-child agent relationships</li> <li>Inheritance of permissions</li> <li> <p>Coordinated lifecycle management</p> </li> <li> <p>State Management:</p> </li> <li>Agent status tracking</li> <li>Metadata persistence</li> <li> <p>Resource state monitoring</p> </li> <li> <p>Tool Extensibility:</p> </li> <li>Custom tool development</li> <li>Plugin architecture</li> <li>Permission-based access control</li> </ol>"},{"location":"architecture/overview/#security-model","title":"Security Model","text":"<p>The framework implements a comprehensive security model: - Permission-based access control for tools and resources - Sandboxed execution environment - Resource limits and monitoring - Secure communication between agents</p>"},{"location":"architecture/overview/#resource-management","title":"Resource Management","text":"<p>Resource management is handled at multiple levels: - Container-level resource limits (CPU, memory) - Tool-level resource tracking - LLM token usage monitoring - Timeout handling for long-running operations</p>"},{"location":"deployment/docker/","title":"Docker Deployment Guide","text":"<p>This guide covers deploying FFC agents using Docker and Kubernetes.</p>"},{"location":"deployment/docker/#docker-configuration","title":"Docker Configuration","text":""},{"location":"deployment/docker/#base-image","title":"Base Image","text":"<p>FFC uses a multi-stage build process with optimized base images: - Build stage: <code>python:3.10-slim</code> - Runtime stage: <code>gcr.io/distroless/python3:nonroot</code></p>"},{"location":"deployment/docker/#container-structure","title":"Container Structure","text":"<pre><code># Build Stage\nFROM python:3.10-slim as builder\nCOPY poetry.lock pyproject.toml ./\nRUN pip install poetry &amp;&amp; \\\n    poetry config virtualenvs.in-project true &amp;&amp; \\\n    poetry install --no-root\n\n# Runtime Stage\nFROM gcr.io/distroless/python3:nonroot\nCOPY --from=builder .venv .venv\nCOPY . .\n</code></pre>"},{"location":"deployment/docker/#resource-configuration","title":"Resource Configuration","text":""},{"location":"deployment/docker/#memory-management","title":"Memory Management","text":"<ul> <li>Container memory limits are configurable</li> <li>Default limits are set in deployment specs</li> <li>Runtime memory monitoring is enabled</li> </ul>"},{"location":"deployment/docker/#cpu-allocation","title":"CPU Allocation","text":"<ul> <li>CPU requests and limits are configurable</li> <li>Default CPU shares are set for fair scheduling</li> <li>CPU usage monitoring is enabled</li> </ul>"},{"location":"deployment/docker/#health-checks","title":"Health Checks","text":""},{"location":"deployment/docker/#http-health-endpoint","title":"HTTP Health Endpoint","text":"<ul> <li>Available at <code>/health</code></li> <li>Returns system metrics and status</li> <li>Configurable check intervals</li> </ul>"},{"location":"deployment/docker/#docker-health-check","title":"Docker Health Check","text":"<pre><code>HEALTHCHECK --interval=30s --timeout=3s --retries=3 \\\n  CMD curl -f http://localhost:8080/health || exit 1\n</code></pre>"},{"location":"deployment/docker/#environment-setup","title":"Environment Setup","text":""},{"location":"deployment/docker/#configuration-management","title":"Configuration Management","text":"<ul> <li>Environment variables for runtime configuration</li> <li>Secret management through Kubernetes</li> <li>Volume management for persistent storage</li> </ul>"},{"location":"deployment/docker/#deployment-commands","title":"Deployment Commands","text":""},{"location":"deployment/docker/#basic-deployment","title":"Basic Deployment","text":"<pre><code>docker run -d \\\n  --name ffc-agent \\\n  -p 8080:8080 \\\n  -v /path/to/logs:/app/logs \\\n  ghcr.io/ffc/agent-runtime:latest\n</code></pre>"},{"location":"deployment/docker/#management-commands","title":"Management Commands","text":"<pre><code># View logs\ndocker logs ffc-agent\n\n# Stop container\ndocker stop ffc-agent\n\n# Start container\ndocker start ffc-agent\n\n# Remove container\ndocker rm -f ffc-agent\n</code></pre>"},{"location":"deployment/docker/#security-considerations","title":"Security Considerations","text":""},{"location":"deployment/docker/#container-security","title":"Container Security","text":"<ul> <li>Non-root user execution</li> <li>Minimal base image</li> <li>No unnecessary packages</li> <li>Regular security updates</li> </ul>"},{"location":"deployment/docker/#network-security","title":"Network Security","text":"<ul> <li>Exposed ports are configurable</li> <li>Internal communication over secure channels</li> <li>Support for network policies</li> </ul>"},{"location":"deployment/docker/#monitoring-and-logging","title":"Monitoring and Logging","text":""},{"location":"deployment/docker/#log-configuration","title":"Log Configuration","text":"<ul> <li>JSON-formatted logging</li> <li>Log rotation enabled</li> <li>Volume mounting for persistence</li> </ul>"},{"location":"deployment/docker/#metrics","title":"Metrics","text":"<ul> <li>Container metrics available</li> <li>Resource usage tracking</li> <li>Health check status monitoring</li> </ul>"},{"location":"examples/basic-agent/","title":"Basic Agent Example","text":"<p>This example demonstrates how to create and run a basic FFC agent.</p>"},{"location":"examples/basic-agent/#simple-file-processing-agent","title":"Simple File Processing Agent","text":"<p>Here's a complete example of an agent that processes files:</p> <pre><code>from ffc.agent import AgentRunner\nfrom pathlib import Path\n\n# Define agent specification\nspec = {\n    \"name\": \"file-processor\",\n    \"description\": \"Processes text files and counts words\",\n    \"tools\": [\n        {\n            \"name\": \"read_file\",\n            \"class\": \"FileSystemTool\",\n            \"config\": {\n                \"operation\": \"read\"\n            }\n        },\n        {\n            \"name\": \"write_file\",\n            \"class\": \"FileSystemTool\",\n            \"config\": {\n                \"operation\": \"write\"\n            }\n        }\n    ],\n    \"permissions\": [\n        {\n            \"resource\": \"data/*\",\n            \"actions\": [\"read\", \"write\"]\n        }\n    ]\n}\n\nasync def main():\n    # Create runner\n    runner = AgentRunner(spec)\n\n    # Start agent\n    await runner.start()\n\n    # Process file\n    result = await runner.execute_command(\n        \"read_file\",\n        path=\"data/input.txt\"\n    )\n\n    if result[\"success\"]:\n        # Count words\n        words = len(result[\"content\"].split())\n\n        # Write results\n        await runner.execute_command(\n            \"write_file\",\n            path=\"data/output.txt\",\n            content=f\"Word count: {words}\"\n        )\n\n    # Stop agent\n    await runner.stop()\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/basic-agent/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Save the code as <code>file_processor.py</code></p> </li> <li> <p>Create input file: <pre><code>echo \"Hello Firefly Catcher Framework!\" &gt; data/input.txt\n</code></pre></p> </li> <li> <p>Run the agent: <pre><code>python file_processor.py\n</code></pre></p> </li> <li> <p>Check the output: <pre><code>cat data/output.txt\n# Should show: Word count: 4\n</code></pre></p> </li> </ol>"},{"location":"examples/basic-agent/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ul> <li>Agent specification structure</li> <li>Tool configuration</li> <li>Permission setup</li> <li>Agent lifecycle management</li> <li>Command execution</li> <li>Error handling</li> </ul>"},{"location":"examples/basic-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Custom Tools Example</li> <li>Learn about Agent Orchestration</li> <li>Explore LLM Integration</li> </ul>"},{"location":"examples/custom-tools/","title":"Custom Tools Example","text":"<p>This example shows how to create and use custom tools in the FFC framework.</p>"},{"location":"examples/custom-tools/#creating-a-custom-tool","title":"Creating a Custom Tool","text":"<p>Here's an example of creating a custom tool for data processing:</p> <pre><code>from typing import Dict, Any\nfrom ffc.core.tools import BaseTool, ToolResult\n\nclass DataProcessingTool(BaseTool):\n    \"\"\"Custom tool for data processing.\"\"\"\n\n    def __init__(self, config: Dict[str, Any]):\n        super().__init__()\n        self.format = config.get(\"format\", \"json\")\n\n    async def execute(\n        self,\n        args: Dict[str, Any],\n        state: Any\n    ) -&gt; ToolResult:\n        try:\n            # Process data based on format\n            data = args.get(\"data\", {})\n            if self.format == \"json\":\n                result = self._process_json(data)\n            elif self.format == \"csv\":\n                result = self._process_csv(data)\n            else:\n                raise ValueError(f\"Unsupported format: {self.format}\")\n\n            return {\n                \"success\": True,\n                \"result\": result\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n\n    def _process_json(self, data: Dict) -&gt; Dict:\n        # Add custom JSON processing logic\n        return {\n            \"processed\": data,\n            \"format\": \"json\"\n        }\n\n    def _process_csv(self, data: str) -&gt; Dict:\n        # Add custom CSV processing logic\n        return {\n            \"processed\": data.split(\",\"),\n            \"format\": \"csv\"\n        }\n</code></pre>"},{"location":"examples/custom-tools/#using-the-custom-tool","title":"Using the Custom Tool","text":"<p>Here's how to use the custom tool in an agent:</p> <pre><code>from ffc.agent import AgentRunner\n\n# Define agent specification with custom tool\nspec = {\n    \"name\": \"data-processor\",\n    \"description\": \"Processes data using custom tool\",\n    \"tools\": [\n        {\n            \"name\": \"process_data\",\n            \"class\": \"DataProcessingTool\",\n            \"config\": {\n                \"format\": \"json\"\n            }\n        }\n    ]\n}\n\nasync def main():\n    # Create and start agent\n    runner = AgentRunner(spec)\n    await runner.start()\n\n    # Process some data\n    result = await runner.execute_command(\n        \"process_data\",\n        data={\"key\": \"value\"}\n    )\n\n    print(result)\n    await runner.stop()\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/custom-tools/#tool-development-best-practices","title":"Tool Development Best Practices","text":"<ol> <li>Error Handling</li> <li>Always return proper ToolResult</li> <li>Include meaningful error messages</li> <li> <p>Handle expected exceptions</p> </li> <li> <p>Configuration</p> </li> <li>Use type hints</li> <li>Validate config in init</li> <li> <p>Provide sensible defaults</p> </li> <li> <p>Documentation</p> </li> <li>Add docstrings</li> <li>Document parameters</li> <li> <p>Include usage examples</p> </li> <li> <p>Testing <pre><code>import pytest\nfrom .tools import DataProcessingTool\n\n@pytest.mark.asyncio\nasync def test_data_processing_tool():\n    tool = DataProcessingTool({\"format\": \"json\"})\n    result = await tool.execute(\n        {\"data\": {\"test\": \"data\"}},\n        {}\n    )\n    assert result[\"success\"]\n    assert result[\"result\"][\"format\"] == \"json\"\n</code></pre></p> </li> </ol>"},{"location":"examples/custom-tools/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/custom-tools/#1-state-management","title":"1. State Management","text":"<pre><code>class StatefulTool(BaseTool):\n    async def execute(self, args: Dict[str, Any], state: Any) -&gt; ToolResult:\n        # Access and modify state\n        current_count = state.get(\"count\", 0)\n        state[\"count\"] = current_count + 1\n        return {\"success\": True, \"result\": state[\"count\"]}\n</code></pre>"},{"location":"examples/custom-tools/#2-async-operations","title":"2. Async Operations","text":"<pre><code>class AsyncTool(BaseTool):\n    async def execute(self, args: Dict[str, Any], state: Any) -&gt; ToolResult:\n        # Perform async operations\n        async with aiohttp.ClientSession() as session:\n            async with session.get(args[\"url\"]) as response:\n                data = await response.json()\n                return {\"success\": True, \"result\": data}\n</code></pre>"},{"location":"examples/custom-tools/#3-resource-management","title":"3. Resource Management","text":"<pre><code>class ResourceTool(BaseTool):\n    async def __aenter__(self):\n        # Acquire resources\n        self.resource = await acquire_resource()\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        # Release resources\n        await release_resource(self.resource)\n</code></pre>"},{"location":"examples/custom-tools/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about permissions in the Architecture Overview</li> <li>Explore LLM Integration</li> <li>See Agent Orchestration</li> </ul>"},{"location":"guides/agent-orchestration/","title":"Agent Orchestration Guide","text":"<p>This guide covers the agent orchestration system in the Firefly Catcher Framework, which enables the creation and management of distributed AI agents.</p>"},{"location":"guides/agent-orchestration/#overview","title":"Overview","text":"<p>The FFC Agent Orchestration system provides: - Distributed agent deployment and management using Kubernetes - Parent-child agent relationships with inheritance - Resource management and monitoring - Permission inheritance and enforcement - Inter-agent communication and coordination</p>"},{"location":"guides/agent-orchestration/#architecture","title":"Architecture","text":"<p>The orchestration system consists of two main components:</p> <pre><code>%%{init: {'theme': 'default'}}%%\ngraph TB\n    subgraph \"Orchestrator Layer\"\n        O[AgentOrchestrator] --&gt; |deploy| K8s[(Kubernetes)]\n        O --&gt; |manage| AM[Agent Metadata]\n        O --&gt; |execute| CMD[Commands]\n        O --&gt; |monitor| Status[Agent Status]\n    end\n\n    subgraph \"Agent Layer\"\n        AR[AgentRunner] --&gt; |runs| E[Engine]\n        E --&gt; |executes| T[Tools]\n        E --&gt; |processes| Tasks[Tasks]\n        AR --&gt; |reports| Status\n    end\n\n    subgraph \"Infrastructure\"\n        K8s --&gt; |creates| P[Pod]\n        P --&gt; |runs| AR\n    end\n\n    Client[Client] --&gt; |1. deploy| O\n    Client --&gt; |2. interact| O\n    O --&gt; |3. manage lifecycle| AR</code></pre>"},{"location":"guides/agent-orchestration/#components","title":"Components","text":""},{"location":"guides/agent-orchestration/#agent-runner","title":"Agent Runner","text":"<p>The <code>AgentRunner</code> is responsible for executing individual agents:</p> <pre><code>from ffc.agent import AgentRunner\nfrom pathlib import Path\n\n# Create runner from specification file\nrunner = await AgentRunner.from_file(Path(\"agent_spec.json\"))\n\n# Start the agent\nawait runner.start()\n\n# Execute commands\nresult = await runner.execute_command(\"analyze_data\")\n\n# Stop the agent\nawait runner.stop()\n</code></pre>"},{"location":"guides/agent-orchestration/#agent-orchestrator","title":"Agent Orchestrator","text":"<p>The <code>AgentOrchestrator</code> manages the lifecycle of distributed agents:</p> <pre><code>from ffc.core.orchestrator import AgentOrchestrator\n\n# Initialize orchestrator\norchestrator = AgentOrchestrator(\n    namespace=\"ffc-agents\",\n    agent_image=\"ffc-agent-runtime:latest\"\n)\n\n# Deploy a new agent\nagent_id = await orchestrator.deploy_agent(spec)\n\n# Get agent status\nstatus = await orchestrator.get_agent_status(agent_id)\n\n# Execute command on agent\nresult = await orchestrator.execute_command(agent_id, \"analyze_data\")\n\n# Terminate agent\nawait orchestrator.terminate_agent(agent_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#agent-lifecycle","title":"Agent Lifecycle","text":""},{"location":"guides/agent-orchestration/#states","title":"States","text":"<ul> <li><code>PENDING</code>: Agent is being initialized</li> <li><code>RUNNING</code>: Agent is actively executing</li> <li><code>FAILED</code>: Agent encountered an error</li> <li><code>TERMINATED</code>: Agent has been stopped</li> <li><code>PAUSED</code>: Agent execution is paused</li> </ul>"},{"location":"guides/agent-orchestration/#lifecycle-management","title":"Lifecycle Management","text":"<pre><code># Pause agent\nawait orchestrator.pause_agent(agent_id)\n\n# Resume agent\nawait orchestrator.resume_agent(agent_id)\n\n# Scale agent resources\nawait orchestrator.scale_agent(agent_id, new_resources)\n\n# Get agent tree\ntree = await orchestrator.get_agent_tree(agent_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#parent-child-relationships","title":"Parent-Child Relationships","text":""},{"location":"guides/agent-orchestration/#creating-child-agents","title":"Creating Child Agents","text":"<pre><code># Parent agent creates child\nchild_spec = {\n    \"name\": \"data-processor\",\n    \"tools\": [\"process_data\", \"store_results\"],\n    \"permissions\": inherited_permissions\n}\n\nchild_id = await runner.execute_command(\"create_agent\", spec=child_spec)\n</code></pre>"},{"location":"guides/agent-orchestration/#managing-relationships","title":"Managing Relationships","text":"<pre><code># Get child agents\nchildren = await orchestrator.get_children(agent_id)\n\n# Get parent agent\nparent = await orchestrator.get_parent(agent_id)\n\n# Terminate all children\nawait orchestrator.terminate_children(agent_id)\n\n# Get full agent hierarchy\nhierarchy = await orchestrator.get_agent_tree(root_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#resource-management","title":"Resource Management","text":""},{"location":"guides/agent-orchestration/#setting-limits","title":"Setting Limits","text":"<pre><code>from ffc.core.schema import ResourceLimits\n\nlimits = ResourceLimits(\n    cpu=\"1\",\n    memory=\"1Gi\",\n    storage=\"5Gi\"\n)\n\nawait orchestrator.deploy_agent(spec, resource_limits=limits)\n</code></pre>"},{"location":"guides/agent-orchestration/#monitoring-usage","title":"Monitoring Usage","text":"<pre><code># Get agent resource usage\nusage = await orchestrator.get_resource_usage(agent_id)\n\n# Get cluster-wide usage\ncluster_usage = await orchestrator.get_cluster_usage()\n\n# Get agent metrics\nmetrics = await orchestrator.get_agent_metrics(agent_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#permission-management","title":"Permission Management","text":""},{"location":"guides/agent-orchestration/#defining-permissions","title":"Defining Permissions","text":"<pre><code>from ffc.core.schema import Permission\n\npermissions = [\n    Permission(resource=\"data/*\", actions=[\"read\"]),\n    Permission(resource=\"results/*\", actions=[\"write\"])\n]\n\nspec[\"permissions\"] = permissions\n</code></pre>"},{"location":"guides/agent-orchestration/#inheritance","title":"Inheritance","text":"<pre><code># Child inherits subset of parent permissions\nchild_permissions = await orchestrator.get_inherited_permissions(\n    parent_id,\n    requested_permissions\n)\n\n# Check permission\nhas_permission = await orchestrator.check_permission(agent_id, permission)\n</code></pre>"},{"location":"guides/agent-orchestration/#communication","title":"Communication","text":""},{"location":"guides/agent-orchestration/#inter-agent-communication","title":"Inter-agent Communication","text":"<pre><code># Send message to another agent\nawait runner.send_message(target_id, message)\n\n# Receive messages\nmessages = await runner.get_messages()\n\n# Subscribe to agent events\nawait runner.subscribe_to_events(event_types=[\"status_change\", \"error\"])\n</code></pre>"},{"location":"guides/agent-orchestration/#broadcasting","title":"Broadcasting","text":"<pre><code># Broadcast to all children\nawait orchestrator.broadcast_to_children(agent_id, message)\n\n# Broadcast to specific agents\nawait orchestrator.broadcast_to_agents(agent_ids, message)\n</code></pre>"},{"location":"guides/agent-orchestration/#error-handling","title":"Error Handling","text":""},{"location":"guides/agent-orchestration/#agent-errors","title":"Agent Errors","text":"<pre><code>try:\n    await orchestrator.deploy_agent(spec)\nexcept AgentDeploymentError as e:\n    # Handle deployment failure\n    logger.error(f\"Deployment failed: {e}\")\n    # Attempt recovery\n    await orchestrator.cleanup_failed_deployment(agent_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#resource-errors","title":"Resource Errors","text":"<pre><code>try:\n    await orchestrator.scale_agent(agent_id, new_resources)\nexcept ResourceLimitError as e:\n    # Handle resource limit exceeded\n    logger.error(f\"Scaling failed: {e}\")\n    # Fall back to default resources\n    await orchestrator.reset_agent_resources(agent_id)\n</code></pre>"},{"location":"guides/agent-orchestration/#best-practices","title":"Best Practices","text":"<ol> <li>Resource Management</li> <li>Set appropriate resource limits based on agent workload</li> <li>Implement resource monitoring and alerts</li> <li>Use auto-scaling for dynamic workloads</li> <li> <p>Clean up resources after agent termination</p> </li> <li> <p>Permission Control</p> </li> <li>Follow principle of least privilege</li> <li>Regularly audit permission inheritance</li> <li>Implement permission checks in critical operations</li> <li> <p>Document permission requirements</p> </li> <li> <p>Error Handling</p> </li> <li>Implement proper error recovery mechanisms</li> <li>Use exponential backoff for retries</li> <li>Log all failures with context</li> <li> <p>Monitor agent health metrics</p> </li> <li> <p>Scaling</p> </li> <li>Use appropriate namespace isolation</li> <li>Implement proper cleanup procedures</li> <li>Monitor cluster capacity</li> <li> <p>Consider resource quotas</p> </li> <li> <p>Communication</p> </li> <li>Use asynchronous communication when possible</li> <li>Implement timeout mechanisms</li> <li>Handle message delivery failures</li> <li> <p>Monitor communication patterns</p> </li> <li> <p>Monitoring</p> </li> <li>Track agent metrics and health</li> <li>Monitor resource usage trends</li> <li>Set up alerts for critical conditions</li> <li>Maintain audit logs</li> </ol>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with the Firefly Catcher Framework.</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Poetry for dependency management</li> <li>Docker (optional, for containerized deployment)</li> </ul>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/zbytealchemy/ffc.git\ncd ffc\n</code></pre></p> </li> <li> <p>Install dependencies: <pre><code>make install\n</code></pre></p> </li> </ol>"},{"location":"guides/getting-started/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Create your first agent specification: <pre><code>name: hello-world\ndescription: \"A simple hello world agent\"\ntools:\n  - name: print\n    class: PrintTool\n</code></pre></p> </li> <li> <p>Run the agent: <pre><code>from ffc.agent import AgentRunner\nfrom pathlib import Path\n\nrunner = await AgentRunner.from_file(Path(\"agent_spec.yaml\"))\nawait runner.start()\n</code></pre></p> </li> </ol>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Architecture Overview</li> <li>Learn about Agent Orchestration</li> <li>Explore Custom Tools</li> </ul>"},{"location":"guides/installation/","title":"Installation Guide","text":""},{"location":"guides/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Poetry for dependency management</li> <li>Docker (optional)</li> <li>Git</li> </ul>"},{"location":"guides/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"guides/installation/#1-install-poetry","title":"1. Install Poetry","text":"<p>If you haven't installed Poetry yet:</p> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre>"},{"location":"guides/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/zbytealchemy/ffc.git\ncd ffc\n</code></pre>"},{"location":"guides/installation/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code># Install all components\nmake install\n</code></pre>"},{"location":"guides/installation/#4-verify-installation","title":"4. Verify Installation","text":"<pre><code># Run tests\nmake test\n\n# Run linting\nmake lint\n</code></pre>"},{"location":"guides/installation/#docker-installation","title":"Docker Installation","text":"<p>If you prefer using Docker:</p> <pre><code># Build development image\nmake docker-dev-build\n\n# Run in container\nmake docker-dev-run\n</code></pre>"},{"location":"guides/installation/#development-setup","title":"Development Setup","text":"<p>For development work:</p> <pre><code># Setup development environment\nmake setup-dev\n\n# This will:\n# 1. Install poetry\n# 2. Install pre-commit hooks\n# 3. Setup git hooks\n# 4. Install all dependencies\n</code></pre>"},{"location":"guides/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues:</p> <ol> <li>Make sure you have the correct Python version</li> <li>Update Poetry to the latest version</li> <li>Clear Poetry cache if needed</li> <li>Check the logs in the <code>logs</code> directory</li> </ol>"},{"location":"guides/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Getting Started Guide</li> <li>Read about Architecture</li> <li>Try the Basic Agent Example</li> </ul>"},{"location":"guides/llm-integration/","title":"LLM Integration Guide","text":"<p>This guide covers integrating Large Language Models (LLMs) with the Firefly Catcher Framework.</p>"},{"location":"guides/llm-integration/#overview","title":"Overview","text":"<p>FFC provides a flexible LLM integration system that supports: - Multiple LLM providers - Template-based prompt management - Context handling - Token management - Error handling and fallback strategies</p>"},{"location":"guides/llm-integration/#provider-configuration","title":"Provider Configuration","text":""},{"location":"guides/llm-integration/#supported-providers","title":"Supported Providers","text":"<ul> <li>OpenAI</li> <li>Anthropic</li> <li>Custom providers</li> </ul>"},{"location":"guides/llm-integration/#configuration-example","title":"Configuration Example","text":"<pre><code>from ffc.llm import LLMConfig, Provider\n\nconfig = LLMConfig(\n    provider=Provider.OPENAI,\n    model=\"gpt-4\",\n    api_key=\"your-api-key\",\n    max_tokens=2000\n)\n</code></pre>"},{"location":"guides/llm-integration/#prompt-management","title":"Prompt Management","text":""},{"location":"guides/llm-integration/#template-system","title":"Template System","text":"<pre><code>from ffc.llm import PromptTemplate\n\ntemplate = PromptTemplate(\n    name=\"task_decomposition\",\n    content=\"Break down the following task into steps: {task}\",\n    variables=[\"task\"]\n)\n</code></pre>"},{"location":"guides/llm-integration/#context-handling","title":"Context Handling","text":"<pre><code>from ffc.llm import Context\n\ncontext = Context()\ncontext.add(\"system_prompt\", \"You are a helpful AI assistant\")\ncontext.add(\"user_context\", user_data)\n</code></pre>"},{"location":"guides/llm-integration/#error-handling","title":"Error Handling","text":""},{"location":"guides/llm-integration/#retry-mechanism","title":"Retry Mechanism","text":"<pre><code>from ffc.llm import RetryConfig\n\nretry_config = RetryConfig(\n    max_retries=3,\n    backoff_factor=1.5,\n    errors_to_retry=[RateLimitError, TemporaryError]\n)\n</code></pre>"},{"location":"guides/llm-integration/#fallback-strategy","title":"Fallback Strategy","text":"<pre><code>from ffc.llm import FallbackConfig\n\nfallback_config = FallbackConfig(\n    providers=[Provider.OPENAI, Provider.ANTHROPIC],\n    models=[\"gpt-4\", \"claude-2\"]\n)\n</code></pre>"},{"location":"guides/llm-integration/#cost-management","title":"Cost Management","text":""},{"location":"guides/llm-integration/#token-tracking","title":"Token Tracking","text":"<pre><code>from ffc.llm import TokenTracker\n\ntracker = TokenTracker()\ntracker.start_session()\n# ... LLM operations ...\nusage = tracker.get_session_usage()\n</code></pre>"},{"location":"guides/llm-integration/#budget-control","title":"Budget Control","text":"<pre><code>from ffc.llm import BudgetManager\n\nbudget = BudgetManager(\n    max_daily_tokens=100000,\n    max_cost_usd=10.0\n)\n</code></pre>"},{"location":"guides/llm-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Token Efficiency</li> <li>Use efficient prompts</li> <li>Implement context windowing</li> <li> <p>Clean and preprocess inputs</p> </li> <li> <p>Error Handling</p> </li> <li>Always implement retry logic</li> <li>Use fallback providers</li> <li> <p>Log and monitor errors</p> </li> <li> <p>Cost Control</p> </li> <li>Set budget limits</li> <li>Monitor token usage</li> <li> <p>Implement cost optimization strategies</p> </li> <li> <p>Security</p> </li> <li>Secure API key storage</li> <li>Sanitize inputs</li> <li>Implement rate limiting</li> </ol>"},{"location":"guides/llm-integration/#example-implementation","title":"Example Implementation","text":"<pre><code>from ffc.llm import LLMManager, PromptTemplate, Context\n\n# Initialize LLM manager\nllm = LLMManager(config)\n\n# Create prompt template\ntemplate = PromptTemplate(\n    name=\"analysis\",\n    content=\"Analyze the following code: {code}\"\n)\n\n# Prepare context\ncontext = Context()\ncontext.add(\"code\", source_code)\n\n# Execute LLM call with retry and fallback\nresult = await llm.generate(\n    template=template,\n    context=context,\n    retry_config=retry_config,\n    fallback_config=fallback_config\n)\n</code></pre>"}]}